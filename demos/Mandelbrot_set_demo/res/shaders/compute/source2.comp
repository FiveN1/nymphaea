#version 460 core
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

struct mbs_cs_data {
    //
    double position_x;
    double position_y;
    double zoom;
    //
    int resolution_x;
    int resolution_y;
    //
    int max_iteration_count;
};

layout(rgba32f, binding = 0) uniform image2D screen;

layout(std430, binding = 1) readonly buffer data_SSBO {
	mbs_cs_data data;
};

layout(std430, binding = 2) readonly buffer color_scheme_SSBO {
	int color_count;
	float colors[];
};




// Map funkce
double map(double value, double min1, double max1, double min2, double max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec3 linear_color_gradient(double gradient_position) {
	// a color segment is the place between colors - there are (color_count - 1) segments in a color gradient.
	int color_segments = (color_count - 1);

	// segment distance in a gradient of size 1.0f
	float segment_distance = 1.0f / color_segments;

	// get segment indexes
	int base_segment = int(floor(gradient_position * color_segments));
	int next_segment = base_segment + 1;

	// color weights
	float base_position = float(base_segment) * segment_distance;
	float next_weight = (float(gradient_position) - base_position) * color_segments;
	float base_weight = 1.0f - next_weight;

	// color - linear color mix, between two colors
	return vec3(colors[base_segment * 3] * base_weight + colors[next_segment * 3] * next_weight, colors[base_segment * 3 + 1] * base_weight + colors[next_segment * 3 + 1] * next_weight, colors[base_segment * 3 + 2] * base_weight + colors[next_segment * 3 + 2] * next_weight);
}




// Tahle funkce pobbezi paralelne na GPU
void main() {

	//----------------------------------------
	// [KALKULACE] - Spocita Fractal
	//----------------------------------------

	// Pixel Coordinace
	ivec2 pixCord = ivec2(gl_GlobalInvocationID.xy);

	// camera
	double camera_position_x = data.position_x;
	double camera_position_y = data.position_y;
	double camera_zoom = data.zoom;
	
	// Iteration
	double a, b, aa, bb, ca, cb, twoab;
	int n = 0;
	int max_iter = data.max_iteration_count;

	// Screen
	double greyscale = 0.0;
	vec3 color = vec3(0.0f, 0.0f, 0.0f);

	a = map(pixCord.x, 0, data.resolution_x, camera_position_x - camera_zoom * 0.5 * (4.0/3.0), camera_position_x + camera_zoom * 0.5 * (4.0/3.0));
	b = map(pixCord.y, 0, data.resolution_y, camera_position_y - camera_zoom * 0.5, camera_position_y + camera_zoom * 0.5);
	ca = a;
	cb = b;
	
	//if (setData == 1) {
		// https://en.wikipedia.org/wiki/Julia_set julia set constants
	//	ca = user[4];
	//	cb = user[5];
	//}

	//ca = -0.9f;
	//cb = 0.679;

	//----------------------------------------
	// [FUNCTION] - Funkce fraktalu
	//----------------------------------------

	// D√ÅT DO FUNKCE

	// Itteruje do max
	for (int i = 0; i < max_iter; i++, n++) {
		aa = a * a;
		bb = b * b;
		twoab = 2.0 * a * b;
		a = aa - bb + ca;
		b = twoab + cb;

		if (aa * aa + bb * bb > 16) {
			break;
		}
	}
	
	// Vykalkuluje barvu danneho pixelu podle vysledku fraktalu
	if (n != max_iter) {
		greyscale = sqrt(double(n) / double(max_iter)) / 1.0;

		color = linear_color_gradient(greyscale);
	} 

	// Ulozi pixel
	imageStore(screen, pixCord, vec4(color, 1.0));
}